---
title: Redisæºç é˜…è¯»(äºŒå) æœåŠ¡å™¨
date: 2018-09-19 11:14:12
tags:
- redis
categories:
- æºç é˜…è¯»
---

### 1. æœåŠ¡å™¨å®šä¹‰

RedisæœåŠ¡æ®µç»“æ„æ˜¯å…¶æœ€æ ¸å¿ƒçš„åŠŸèƒ½ç»“æ„ï¼Œè´Ÿè´£ç»´æŠ¤ä¸å®¢æˆ·ç«¯é”®çš„ç½‘ç»œè¿æ¥ï¼Œç»´æŠ¤æ•°æ®åº“çŠ¶æ€ï¼Œæ‰§è¡Œå®¢æˆ·ç«¯çš„å‘½ä»¤è¯·æ±‚ï¼Œç»Ÿè®¡ä¸€äº›è¿è¡Œæ•°æ®ç­‰ç­‰ã€‚

```c
struct redisServer {
    /* General */
    // ç¨‹åºè¿è¡Œä¸»è¿›ç¨‹pid
    pid_t pid;                  /* Main process pid. */
    // é…ç½®æ–‡ä»¶ç»å¯¹è·¯å¾„
    char *configfile;           /* Absolute config file path, or NULL */
    // å¯æ‰§è¡Œæ–‡ä»¶ç»å¯¹è·¯å¾„
    char *executable;           /* Absolute executable file path. */
    // æ‰§è¡Œexecutableæ—¶çš„å‘½ä»¤è¡Œå‚æ•°
    char **exec_argv;           /* Executable argv vector (copy). */
    // serverCron()è°ƒç”¨é¢‘ç‡
    int hz;                     /* serverCron() calls frequency in hertz */

    // RedisDBå¯¹è±¡ï¼Œé•¿åº¦16ï¼Œæ¯ä¸ªéƒ½å­˜å‚¨äº†Redisæ•°æ®åº“å¯¹è±¡
    redisDb *db;

    //  å‘½ä»¤è¡¨
    dict *commands;             /* Command table */
    // renameä¹‹å‰çš„å‘½ä»¤è¡¨
    dict *orig_commands;        /* Command table before command renaming. */

    // äº‹ä»¶å¾ªç¯
    aeEventLoop *el;

    // æœåŠ¡å™¨LRUæ—¶é’Ÿ
    unsigned int lruclock;      /* Clock for LRU eviction */
    // ç«‹å³å…³é—­æœåŠ¡å™¨
    int shutdown_asap;          /* SHUTDOWN needed ASAP */
    // åœ¨æ‰§è¡ŒserverCron()æœŸé—´è¿›è¡Œrehash
    int activerehashing;        /* Incremental rehash in serverCron() */
    // ä¸»åŠ¨è¿›è¡Œç¢ç‰‡æ•´ç†
    int active_defrag_running;  /* Active defragmentation running (holds current scan aggressiveness) */
    // æ˜¯å¦è®¾ç½®äº†å¯†ç 
    char *requirepass;          /* Pass for AUTH command, or NULL */
    // PIDæ–‡ä»¶è·¯å¾„
    char *pidfile;              /* PID file path */
    // æ¶æ„ç±»å‹ï¼Œ32ä½æˆ–64ä½
    int arch_bits;              /* 32 or 64 depending on sizeof(long) */
    // serverCron()è¿è¡Œæ¬¡æ•°è®¡æ•°
    int cronloops;              /* Number of times the cron function run */
    // æœåŠ¡å™¨è¿è¡ŒIDï¼Œæ¯æ¬¡é‡å¯éƒ½ä¼šåˆ†é…æ–°çš„id
    char runid[CONFIG_RUN_ID_SIZE+1];  /* ID always different at every exec. */
    // æœåŠ¡å™¨æ˜¯å¦è¿è¡Œåœ¨Sentinelæ¨¡å¼
    int sentinel_mode;          /* True if this instance is a Sentinel. */
    // æœåŠ¡å™¨åˆå§‹åŒ–åä½¿ç”¨å†…å­˜çš„å¤§å°
    size_t initial_memory_usage; /* Bytes used after initialization. */
    // éæ ‡å‡†è¾“å‡ºä¹Ÿä¼šè®°å½•Redisçš„logo
    int always_show_logo;       /* Show logo even for non-stdout logging. */

    /* Modules */
    // æ¨¡å—æš´éœ²çš„API
    dict *moduleapi;            /* Exported APIs dictionary for modules. */
    // æœåŠ¡å™¨å¯åŠ¨æ—¶éœ€è¦åŠ è½½çš„æ¨¡å—
    list *loadmodule_queue;     /* List of modules to load at startup. */
    // è¿™ä¸ªpipeç”¨æ¥å”¤é†’äº‹ä»¶å¾ªç¯ä¸­çš„éœ€è¦moduleå‘½ä»¤å¤„ç†çš„é˜»å¡å®¢æˆ·ç«¯
    int module_blocked_pipe[2]; /* Pipe used to awake the event loop if a
                                   client blocked on a module command needs
                                   to be processed. */

    /* Networking */
    // ç›‘å¬ç«¯å£å·
    int port;                   /* TCP listening port */
    // listen()å‡½æ•°çš„backlogå‚æ•°
    int tcp_backlog;            /* TCP listen() backlog */
    // ç»‘å®šçš„åœ°å€
    char *bindaddr[CONFIG_BINDADDR_MAX]; /* Addresses we should bind to */
    // ç»‘å®šåœ°å€çš„æ•°é‡
    int bindaddr_count;         /* Number of addresses in server.bindaddr[] */
    // UNIXå¥—æ¥å­—
    // socketè·¯å¾„
    char *unixsocket;           /* UNIX socket path */
    // socketæ¨¡å¼
    mode_t unixsocketperm;      /* UNIX socket permission */
    // TCPsocketçš„æ–‡ä»¶æè¿°ç¬¦
    int ipfd[CONFIG_BINDADDR_MAX]; /* TCP socket file descriptors */
    // TCPæ–‡ä»¶æè¿°ç¬¦æ•°é‡
    int ipfd_count;             /* Used slots in ipfd[] */
    // UNIX socketæ–‡ä»¶æè¿°ç¬¦æ•°é‡
    int sofd;                   /* Unix socket file descriptor */
    // é›†ç¾¤æ–‡ä»¶æè¿°ç¬¦
    int cfd[CONFIG_BINDADDR_MAX];/* Cluster bus listening socket */
    // é›†ç¾¤æ–‡ä»¶æè¿°ç¬¦æ•°é‡
    int cfd_count;              /* Used slots in cfd[] */
    // æœåŠ¡å™¨å®¢æˆ·ç«¯é“¾è¡¨ï¼Œå­˜å‚¨æ‰€æœ‰çš„å®¢æˆ·ç«¯
    list *clients;              /* List of active clients */
    // å³å°†å…³é—­çš„å®¢æˆ·ç«¯é“¾è¡¨
    list *clients_to_close;     /* Clients to close asynchronously */
    // å‡†å¤‡å†™æ“ä½œæˆ–å®‰è£…å†™å¤„ç†ç¨‹åºçš„å®¢æˆ·ç«¯é“¾è¡¨
    list *clients_pending_write; /* There is to write or install handler. */
    // ä»èŠ‚ç‚¹é“¾è¡¨ï¼Œç›‘æ§å®¢æˆ·ç«¯é“¾è¡¨
    list *slaves, *monitors;    /* List of slaves and MONITORs */
    // å½“å‰å®¢æˆ·ç«¯ï¼Œä»…ç”¨äºå´©æºƒæŠ¥å‘Š
    client *current_client; /* Current client, only used on crash report */
    // å®¢æˆ·ç«¯æ˜¯å¦å¤„äºæš‚åœ
    int clients_paused;         /* True if clients are currently paused */
    // å–æ¶ˆæš‚åœçŠ¶æ€æ—¶é—´
    mstime_t clients_pause_end_time; /* Time when we undo clients_paused */
    // ç½‘ç»œé”™è¯¯ç¼“å†²åŒº
    char neterr[ANET_ERR_LEN];   /* Error buffer for anet.c */
    // è¿ç§»ç¼“å­˜å¥—æ¥å­—çš„å­—å…¸ï¼Œé”®ï¼šhost:ipï¼Œå€¼ï¼šTCPå¥—æ¥å­—ç»“æ„
    dict *migrate_cached_sockets;/* MIGRATE cached sockets */
    // ä¸‹ä¸€ä¸ªå®¢æˆ·ç«¯ID
    uint64_t next_client_id;    /* Next client unique ID. Incremental. */
    // ä¿æŠ¤æ¨¡å¼ï¼Œä¸æ¥å—å¤–éƒ¨é“¾æ¥, ä»…æœ¬åœ°è¿æ¥
    int protected_mode;         /* Don't accept external connections. */

    /* RDB / AOF loading information */
    // æœåŠ¡å™¨å¤„äºåŠ è½½çŠ¶æ€ï¼Œä»RDB/AOFæ–‡ä»¶æ¢å¤ä¸­
    int loading;                /* We are loading data from disk if true */
    // è¦åŠ è½½çš„æ€»å­—èŠ‚æ•°
    off_t loading_total_bytes;
    // å·²ç»åŠ è½½çš„å­—èŠ‚æ•°
    off_t loading_loaded_bytes;
    // åŠ è½½å¼€å§‹æ—¶é—´
    time_t loading_start_time;
    // åŠ è½½è¿‡ç¨‹ä¸­ï¼Œè¯»å†™çš„æœ€å¤§å—å­—èŠ‚æ•°
    off_t loading_process_events_interval_bytes;

    /* Fast pointers to often looked up command */
    // Rediså‘½ä»¤
    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,
                        *rpopCommand, *sremCommand, *execCommand, *expireCommand,
                        *pexpireCommand;

    /* Fields used only for stats */
    // æœåŠ¡å™¨å¼€å§‹æ—¶é—´
    time_t stat_starttime;          /* Server start time */
    // æ‰§è¡Œå‘½ä»¤çš„æ•°é‡
    long long stat_numcommands;     /* Number of processed commands */
    // æ¥æ”¶è¿æ¥çš„æ•°é‡
    long long stat_numconnections;  /* Number of connections received */
    // è¿‡æœŸé”®çš„æ•°é‡
    long long stat_expiredkeys;     /* Number of expired keys */
    // é”®å¯èƒ½è¿‡æœŸçš„ç™¾åˆ†æ¯”
    double stat_expired_stale_perc; /* Percentage of keys probably expired */
    // åˆ é™¤è¿‡æœŸé”®æ—¶ï¼Œå¦‚æœè¿‡æœŸé”®å¤ªå¤šä½†æˆ‘ä»¬ä¸èƒ½ä¸€ç›´è¿›è¡Œåˆ é™¤ï¼Œæ‰€ä»¥è®¾å®šäº†æ—¶é—´
    // è¶…è¿‡è¯¥æ—¶é—´ï¼Œåˆ™é€€å‡ºå¾ªç¯ç­‰å¾…ä¸‹ä¸€æ¬¡åˆ é™¤ï¼Œè¯¥å±æ€§è®°å½•è¶…è¿‡è¯¥æ—¶é—´çš„æ¬¡æ•°
    long long stat_expired_time_cap_reached_count; /* Early expire cylce stops.*/
    // LFUç®—æ³•ä¸­ï¼Œé©±é€keyçš„æ¬¡æ•°
    long long stat_evictedkeys;     /* Number of evicted keys (maxmemory) */
    // æˆåŠŸå‘½ä¸­keyçš„æ¬¡æ•°
    long long stat_keyspace_hits;   /* Number of successful lookups of keys */
    // æ²¡æœ‰å‘½ä¸­keyçš„æ¬¡æ•°
    long long stat_keyspace_misses; /* Number of failed lookups of keys */
    // æ•´ç†å†…å­˜ç¢ç‰‡å‘½ä¸­æ¬¡æ•°
    long long stat_active_defrag_hits;      /* number of allocations moved */
    // æ•´ç†å†…å­˜ç¢ç‰‡æ²¡æœ‰å‘½ä¸­æ¬¡æ•°
    long long stat_active_defrag_misses;    /* number of allocations scanned but not moved */
    // æ•´ç†å†…å­˜ç¢ç‰‡keyè¢«é‡æ–°åˆ†é…çš„æ¬¡æ•°
    long long stat_active_defrag_key_hits;  /* number of keys with moved allocations */
    // æ•´ç†å†…å­˜ç¢ç‰‡æ‰«æåˆ°keyä½†æ²¡æœ‰ç§»åŠ¨çš„æ¬¡æ•°
    long long stat_active_defrag_key_misses;/* number of keys scanned and not moved */
    // ä½¿ç”¨çš„å†…å­˜å³°å€¼
    size_t stat_peak_memory;        /* Max used memory record */
    // æ‰§è¡Œfork()çš„æ—¶é—´
    long long stat_fork_time;       /* Time needed to perform latest fork() */
    // æ‰§è¡Œfork()çš„é€Ÿç‡
    double stat_fork_rate;          /* Fork rate in GB/sec. */
    // å› ä¸ºæœ€å¤§å®¢æˆ·ç«¯æ•°ï¼Œæ‹’ç»å®¢æˆ·ç«¯è¿æ¥çš„æ¬¡æ•°
    long long stat_rejected_conn;   /* Clients rejected because of maxclients */
    // æ‰§è¡Œä»èŠ‚ç‚¹å…¨é‡åŒæ­¥çš„æ¬¡æ•°
    long long stat_sync_full;       /* Number of full resyncs with slaves. */
    // æˆåŠŸæ¥å—PSYNCçš„æ¬¡æ•°
    long long stat_sync_partial_ok; /* Number of accepted PSYNC requests. */
    // é”™è¯¯æ¥å—PSYNCçš„æ¬¡æ•°
    long long stat_sync_partial_err;/* Number of unaccepted PSYNC requests. */

    // æ…¢æŸ¥è¯¢å‘½ä»¤é“¾è¡¨
    list *slowlog;                  /* SLOWLOG list of commands */
    // å½“å‰æ…¢æŸ¥è¯¢çš„æ—¥å¿—ID
    long long slowlog_entry_id;     /* SLOWLOG current entry ID */
    // æ…¢æŸ¥è¯¢çš„è¯„å®šæ—¶é—´
    long long slowlog_log_slower_than; /* SLOWLOG time limit (to get logged) */
    // æ…¢æŸ¥è¯¢çš„æœ€å¤§æ•°é‡
    unsigned long slowlog_max_len;     /* SLOWLOG max number of items logged */

    // serverCron() ä¸­é‡‡ç”¨RSS, å¸¸é©»å†…å­˜å¤§å°
    size_t resident_set_size;       /* RSS sampled in serverCron(). */
    // è¯»å–ç½‘ç»œå­—èŠ‚æ•°
    long long stat_net_input_bytes; /* Bytes read from network. */
    // è¾“å‡ºç½‘ç»œå­—èŠ‚æ•°
    long long stat_net_output_bytes; /* Bytes written to network. */
    // RDBä¿å­˜æ—¶å†™æ—¶å¤åˆ¶çš„å­—èŠ‚æ•°
    size_t stat_rdb_cow_bytes;      /* Copy on write bytes during RDB saving. */
    // AOFæ‰§è¡Œæ—¶å†™æ—¶å¤åˆ¶çš„å­—èŠ‚æ•°
    size_t stat_aof_cow_bytes;      /* Copy on write bytes during AOF rewrite. */

    /* The following two are used to track instantaneous metrics, like
     * number of operations per second, network traffic. */
    // ç”¨æ¥è¿½è¸ªç¬æ—¶æ•°æ®ï¼Œä¾‹å¦‚æ¯ç§’æ“ä½œæ•°ï¼Œç½‘ç»œæµé‡ç­‰
    struct {
        // ä¸Šæ¬¡é‡‡æ ·çš„æ—¶é—´æˆ³
        long long last_sample_time; /* Timestamp of last sample in ms */
        // ä¸Šæ¬¡é‡‡ç”¨çš„æ•°é‡
        long long last_sample_count;/* Count in last sample */
        // é‡‡ç”¨æ•°æ®
        long long samples[STATS_METRIC_SAMPLES];
        // ä¸‹æ ‡
        int idx;
    } inst_metric[STATS_METRIC_COUNT];

    /* Configuration */
    // æ—¥å¿—çº§åˆ«
    int verbosity;                  /* Loglevel in redis.conf */
    // å®¢æˆ·ç«¯æœ€å¤§ç©ºé—²æ—¶é—´ï¼Œè¶…è¿‡ä¼šè¶…æ—¶
    int maxidletime;                /* Client timeout in seconds */
    // å¼€å¯SO_KEEPALIVEé€‰é¡¹
    int tcpkeepalive;               /* Set SO_KEEPALIVE if non-zero. */
    // å¼€å¯è¿‡æœŸ
    int active_expire_enabled;      /* Can be disabled for testing purposes. */
    // å¼€å¯å†…å­˜æ•´ç†
    int active_defrag_enabled;
    // å†…å­˜ç¢ç‰‡æ•´ç†çš„æ ‡å‡†ï¼Œå°äºè¿™ä¸ªå€¼ä¼šå¿½ç•¥
    size_t active_defrag_ignore_bytes; /* minimum amount of fragmentation waste to start active defrag */
    // å†…å­˜ç¢ç‰‡çš„æœ€å°æ¯”ä¾‹ï¼Œå¼€å¯å†…å­˜æ•´ç†
    int active_defrag_threshold_lower; /* minimum percentage of fragmentation to start active defrag */
    // ç¢ç‰‡çš„æœ€å¤§æ¯”ä¾‹
    int active_defrag_threshold_upper; /* maximum percentage of fragmentation at which we use maximum effort */
    // ç¢ç‰‡æ•´ç†çš„CPUå ç”¨æœ€å°æ¯”ä¾‹
    int active_defrag_cycle_min;       /* minimal effort for defrag in CPU percentage */
    // ç¢ç‰‡æ•´ç†çš„CPUå ç”¨æœ€å¤§æ¯”ä¾‹
    int active_defrag_cycle_max;       /* maximal effort for defrag in CPU percentage */
    // å®¢æˆ·ç«¯æŸ¥è¯¢ç¼“å†²åŒºçš„æœ€å¤§é•¿åº¦
    size_t client_max_querybuf_len; /* Limit for client query buffer length */

    // æœåŠ¡å™¨æ•°æ®åº“çš„æ•°é‡
    int dbnum;                      /* Total number of configured DBs */

    // 1è¡¨ç¤ºæœ‰ç›‘ç£ï¼Œ0è¡¨ç¤ºæ²¡æœ‰
    int supervised;                 /* 1 if supervised, 0 otherwise. */
    // ç›‘ç£æ¨¡å¼
    int supervised_mode;            /* See SUPERVISED_* */
    // æ˜¯å¦è¿è¡Œåœ¨å®ˆæŠ¤æ¨¡å¼
    int daemonize;                  /* True if running as a daemon */
    // ä¸åŒç±»å‹çš„å®¢æˆ·ç«¯è¾“å‡ºç¼“å†²åŒºé™åˆ¶
    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];

    /* AOF persistence */
    // æœåŠ¡å™¨AOFçŠ¶æ€
    int aof_state;                  /* AOF_(ON|OFF|WAIT_REWRITE) */
    // æœåŠ¡å™¨AOFçš„fsyncç­–ç•¥
    int aof_fsync;                  /* Kind of fsync() policy */
    // æœåŠ¡å™¨AOFæ–‡ä»¶å
    char *aof_filename;             /* Name of the AOF file */
    // å¦‚æœæœ‰aofæ‰§è¡Œï¼Œåˆ™ä¸è¿›è¡Œfsync
    int aof_no_fsync_on_rewrite;    /* Don't fsync if a rewrite is in prog. */
    // AOFå¢é•¿æ¯”ç‡ï¼Œé»˜è®¤100
    int aof_rewrite_perc;           /* Rewrite AOF if % growth is > M and... */
    // AOFæœ€å°å­—èŠ‚æ•°
    off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */
    // AOFåˆå§‹å­—èŠ‚æ•°
    off_t aof_rewrite_base_size;    /* AOF size on latest startup or rewrite. */
    // AOFå½“å‰å­—èŠ‚æ•°
    off_t aof_current_size;         /* AOF current size. */
    // AOFé‡å†™æä¸Šæ—¥ç¨‹ï¼ŒBGSAVEå®Œæˆç«‹å³æ‰§è¡Œ
    int aof_rewrite_scheduled;      /* Rewrite once BGSAVE terminates. */
    // AOFå­è¿›ç¨‹pid
    pid_t aof_child_pid;            /* PID if rewriting process */
    // AOFç¼“å†²åŒºé“¾è¡¨
    list *aof_rewrite_buf_blocks;   /* Hold changes during an AOF rewrite. */
    // AOFç¼“å†²åŒº
    sds aof_buf;      /* AOF buffer, written before entering the event loop */
    // AOFæ–‡ä»¶æè¿°ç¬¦
    int aof_fd;       /* File descriptor of currently selected AOF file */
    // AOFé€‰ä¸­çš„db
    int aof_selected_db; /* Currently selected DB in AOF */
    // å»¶è¿Ÿæ‰§è¡Œflushæ“ä½œçš„å¼€å§‹æ—¶é—´
    time_t aof_flush_postponed_start; /* UNIX time of postponed AOF flush */
    // æœ€åä¸€æ¬¡fsyncçš„ç›´æ¥
    time_t aof_last_fsync;            /* UNIX time of last fsync() */
    // AOFæ‰§è¡Œæœ€åæ—¶é—´
    time_t aof_rewrite_time_last;   /* Time used by last AOF rewrite run. */
    // AOFæ‰§è¡Œå¼€å§‹æ—¶é—´
    time_t aof_rewrite_time_start;  /* Current AOF rewrite start time. */
    // AOFæ‰§è¡Œçš„çŠ¶æ€
    int aof_lastbgrewrite_status;   /* C_OK or C_ERR */
    // å»¶è¿Ÿfsyncçš„æ¬¡æ•°
    unsigned long aof_delayed_fsync;  /* delayed AOF fsync() counter */
    // é‡å†™æ—¶æ˜¯å¦å¼€å¯å¢é‡å¼åŒæ­¥ï¼Œæ¯æ¬¡å†™å…¥AOF_AUTOSYNC_BYTESä¸ªå­—èŠ‚ï¼Œå°±æ‰§è¡Œä¸€æ¬¡åŒæ­¥
    int aof_rewrite_incremental_fsync;/* fsync incrementally while rewriting? */
    // ä¸Šä¸€æ¬¡AOFæ“ä½œçŠ¶æ€
    int aof_last_write_status;      /* C_OK or C_ERR */
    // åˆ ä¸€æ¬¡AOFæ“ä½œé”™è¯¯
    int aof_last_write_errno;       /* Valid if aof_last_write_status is ERR */
    int aof_load_truncated;         /* Don't stop on unexpected AOF EOF. */
    int aof_use_rdb_preamble;       /* Use RDB preamble on AOF rewrites. */

    /* AOF pipes used to communicate between parent and child during rewrite. */
    // è¿›ç¨‹é€šä¿¡æ–‡ä»¶æè¿°æè¿°ç¬¦ï¼Œç®¡é“
    int aof_pipe_write_data_to_child;
    int aof_pipe_read_data_from_parent;
    int aof_pipe_write_ack_to_parent;
    int aof_pipe_read_ack_from_child;
    int aof_pipe_write_ack_to_child;
    int aof_pipe_read_ack_from_parent;
    int aof_stop_sending_diff;     /* If true stop sending accumulated diffs
                                      to child process. */
    // ä¿å­˜å­è¿›ç¨‹AOFæ—¶ç´¯ç§¯æ•°æ®çš„sds
    sds aof_child_diff;             /* AOF diff accumulator child side. */

    /* RDB persistence */
    // è®°å½•æ•°æ®åº“è¢«ä¿®æ”¹çš„æ¬¡æ•°
    long long dirty;                /* Changes to DB from the last save */
    // BGSAVEæ‰§è¡Œå‰ï¼Œéœ€è¦å¤‡ä»½dirty
    long long dirty_before_bgsave;  /* Used to restore dirty on failed BGSAVE */
    // æ‰§è¡ŒBGSAVEçš„å­è¿›ç¨‹pid
    pid_t rdb_child_pid;            /* PID of RDB saving child */
    // RDBæ‰§è¡Œçš„å‚æ•°
    struct saveparam *saveparams;   /* Save points array for RDB */
    // saveå‚æ•°çš„é•¿åº¦
    int saveparamslen;              /* Number of saving points */
    // rdbæ–‡ä»¶åç§°
    char *rdb_filename;             /* Name of RDB file */
    // æ˜¯å¦é‡‡ç”¨LZFå‹ç¼©ç®—æ³•å‹ç¼©RDBæ–‡ä»¶
    int rdb_compression;            /* Use compression in RDB? */
    // RDBæ˜¯å¦ä½¿ç”¨æ ¡éªŒå’Œ
    int rdb_checksum;               /* Use RDB checksum? */
    // ä¸Šä¸€æ¬¡saveæˆåŠŸçš„å®é™…
    time_t lastsave;                /* Unix time of last successful save */
    // ä¸Šä¸€æ¬¡å°è¯•bgsaveçš„å®é™…
    time_t lastbgsave_try;          /* Unix time of last attempted bgsave */
    // ä¸Šä¸€æ¬¡saveæ‰§è¡Œçš„å®é™…
    time_t rdb_save_time_last;      /* Time used by last RDB save run. */
    // RDBä¿å­˜å¼€å§‹æ—¶é—´
    time_t rdb_save_time_start;     /* Current RDB save start time. */
    // BGSAVEè®¡åˆ’
    int rdb_bgsave_scheduled;       /* BGSAVE when possible if true. */
    // rdbæ‰§è¡Œçš„ç±»å‹ï¼Œå†™å…¥ç£ç›˜è¿˜æ˜¯ä»èŠ‚ç‚¹socket
    int rdb_child_type;             /* Type of save by active child. */
    // ä¸Šä¸€æ¬¡BGSAVEæ‰§è¡Œçš„çŠ¶æ€
    int lastbgsave_status;          /* C_OK or C_ERR */
    // BGSAVEå‡ºé”™åˆ™åœæ­¢å†™
    int stop_writes_on_bgsave_err;  /* Don't allow writes if can't BGSAVE */
    // rdbç®¡é“å†™ç«¯
    int rdb_pipe_write_result_to_parent; /* RDB pipes used to return the state */
    // rdbç®¡é“è¯»ç«¯, ä½¿ç”¨æ— ç›˜åŒæ­¥
    int rdb_pipe_read_result_from_child; /* of each slave in diskless SYNC. */
    /* Pipe and data structures for child -> parent info sharing. */
    int child_info_pipe[2];         /* Pipe used to write the child_info_data. */

    // å­è¿›ç¨‹ä¿¡æ¯
    struct {
        // AOF æˆ– RDB
        int process_type;           /* AOF or RDB child? */
        // å†™æ—¶å¤åˆ¶çš„å¤§å°
        size_t cow_size;            /* Copy on write size. */
        unsigned long long magic;   /* Magic value to make sure data is valid. */
    } child_info_data;

    /* Propagation of commands in AOF / replication */
    // ä¼ é€’ç»™AOF/replicationçš„ä¸€äº›å‘½ä»¤
    redisOpArray also_propagate;    /* Additional command to propagate. */

    /* Logging */
    // æ—¥å¿—æ–‡ä»¶è·¯å¾„
    char *logfile;                  /* Path of log file */
    // æ˜¯å¦å¼€å¯ç³»ç»Ÿæ—¥å¿—
    int syslog_enabled;             /* Is syslog enabled? */
    // ç³»ç»Ÿæ—¥å¿—æ ‡è¯†
    char *syslog_ident;             /* Syslog ident */
    int syslog_facility;            /* Syslog facility */

    // ...

    /* Replication (slave) */
    // masterç»“ç‚¹çš„éªŒè¯å¯†ç 
    char *masterauth;               /* AUTH with this password with master */
    // masterç»“ç‚¹çš„åœ°å€
    char *masterhost;               /* Hostname of master */
    // masterç»“ç‚¹çš„ç«¯å£å·
    int masterport;                 /* Port of master */

    // ...
    
    /* Synchronous replication. */
    // ç­‰å¾…WAITå‘½ä»¤çš„å®¢æˆ·ç«¯é“¾è¡¨
    list *clients_waiting_acks;         /* Clients waiting in WAIT command. */
    // è¯»å–ä»èŠ‚ç‚¹ack
    int get_ack_from_slaves;            /* If true we send REPLCONF GETACK. */

    /* Limits */
    // åŒæ—¶æœ€å¤šè¿æ¥çš„å®¢æˆ·ç«¯æ•°é‡
    unsigned int maxclients;            /* Max number of simultaneous clients */
    // æœåŠ¡å™¨ä½¿ç”¨å†…å­˜çš„æœ€å¤§å€¼
    unsigned long long maxmemory;   /* Max number of memory bytes to use */
    // é”®å ç”¨å†…å­˜å›æ”¶ç­–ç•¥
    int maxmemory_policy;           /* Policy for key eviction */
    // éšæœºé‡‡æ ·çš„ä¸ªæ•°
    int maxmemory_samples;          /* Pricision of random sampling */
    // LFU å¯¹æ•°è®¡æ•°å› å­
    int lfu_log_factor;             /* LFU logarithmic counter factor. */
    // LFU åè¡°å‡å› å­
    int lfu_decay_time;             /* LFU counter decay factor. */
    // æ‰¹é‡åè®®æœ€å¤§é•¿åº¦
    long long proto_max_bulk_len;   /* Protocol bulk length maximum size. */

    /* Blocked clients */
    // é˜»å¡çš„å®¢æˆ·ç«¯æ•°é‡
    unsigned int bpop_blocked_clients; /* Number of clients blocked by lists */
    // é˜»å¡çš„å®¢æˆ·ç«¯é“¾è¡¨
    list *unblocked_clients; /* list of clients to unblock before next loop */
    // BLPOPå‘½ä»¤äº§ç”Ÿçš„é˜»å¡é”®åˆ—è¡¨
    list *ready_keys;        /* List of readyList structures for BLPOP & co */

    /* Sort parameters - qsort_r() is only available under BSD so we
     * have to take this state global, in order to pass it to sortCompare() */
    // é™åºæ’åº
    int sort_desc;
    // æ ¹æ®å­—æ¯æ’åº
    int sort_alpha;
    // æ ¹æ®æ¨¡å¼æ’åº
    int sort_bypattern;
    // æ ¹æ®åˆ†æ•°æ’åº
    int sort_store;

    /* Zip structure config, see redis.conf for more information  */
    // ziplistæœ€å¤§ç»“ç‚¹ä¸ªæ•°
    size_t hash_max_ziplist_entries;
    // ziplistç»“ç‚¹æœ€å¤§å†…å­˜
    size_t hash_max_ziplist_value;
    // setæ•´æ•°é›†åˆæœ€å¤§ç»“ç‚¹æ•°
    size_t set_max_intset_entries;
    // zsetå‹ç¼©åˆ—è¡¨æœ€å¤§ç»“ç‚¹æ•°
    size_t zset_max_ziplist_entries;
    // zsetå‹ç¼©åˆ—è¡¨ç»“ç‚¹æœ€å¤§å†…å­˜
    size_t zset_max_ziplist_value;
    size_t hll_sparse_max_bytes;

    /* List parameters */
    // listå‹ç¼©åˆ—è¡¨æœ€å¤§é•¿åº¦
    int list_max_ziplist_size;
    // listå‹ç¼©åˆ—è¡¨å‹ç¼©ç¨‹åº¦
    int list_compress_depth;

    /* time cache */
    // å¾ªç¯é‡‡ç”¨ä¸–ç•Œ
    time_t unixtime;    /* Unix time sampled every cron cycle. */
    long long mstime;   /* Like 'unixtime' but with milliseconds resolution. */

    /* Pubsub */
    // å®¢æˆ·ç«¯è®¢é˜…channelçš„å­—å…¸
    dict *pubsub_channels;  /* Map channels to list of subscribed clients */
    // pubsubå®šä¹‰æ¨¡å¼
    list *pubsub_patterns;  /* A list of pubsub_patterns */
    // é€šè¿‡Pub/Subä¼ é€’äº‹ä»¶
    int notify_keyspace_events; /* Events to propagate via Pub/Sub. This is an
                                   xor of NOTIFY_... flags. */

    /* Cluster */
    // ...

    /* Scripting */
    // ...
    
    // ...
};
```



### 2. Rediså‘½ä»¤

#### 2.1 å‘½ä»¤è¡¨ commands

å‘½ä»¤è¡¨å­˜å‚¨äº†Rediså¯æ‰§è¡Œçš„å‘½ä»¤å­—å…¸ï¼Œå¹¶å¯¹æ¯ä¸ªå‘½ä»¤è®¾å®šäº†ä¸€äº›æ‰§è¡Œå‚æ•°ã€‚orig_commandsæ˜¯é‡å‘½åä¹‹åçš„å‘½ä»¤è¡¨ï¼Œé€šè¿‡é‡å‘½åå¯ä»¥æå‡Redisçš„å®‰å…¨æ€§ï¼Œæ¯”å¦‚è®²KEYS, FLUSHDBè¿™ç±»çš„å‘½ä»¤é‡å‘½åä¸ºåˆ«çš„ï¼Œè¿™æ ·ä¸€èˆ¬ç”¨æˆ·åœ¨å°±ä¸çŸ¥é“å…¶çœŸå®çš„å‘½ä»¤ã€‚

- å‘½ä»¤ç»“æ„è¡¨ç¤ºå¦‚ä¸‹

| å­—æ®µå          | æè¿°                                                         |
| --------------- | ------------------------------------------------------------ |
| name            | å‘½åçš„åç§°ï¼Œç”¨æˆ·æ‰§è¡Œå‘½ä»¤é€šè¿‡æŸ¥æ‰¾å‘½ä»¤è¡¨åŒ¹é…è¯¥å­—æ®µæ¥å¯»æ‰¾ç›¸åº”çš„å‘½ä»¤ |
| function        | æ‰§è¡Œå‘½ä»¤å®ç°çš„æ–¹æ³•                                           |
| arity           | å‘½ä»¤å‚æ•°çš„ä¸ªæ•°ï¼Œ-Nè¡¨ç¤ºå¤§äºç­‰äºNã€‚å‘½ä»¤æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå‚æ•°        |
| sflags          | å­—ç¬¦ä¸²å½¢å¼æ ‡è¯†ç¬¦ï¼Œç”¨äºè®¾ç½®å‘½ä»¤çš„å±æ€§                         |
| flags           | sflagsæ ‡è¯†ç¬¦çš„äºŒè¿›åˆ¶æ ‡è¯†ï¼Œç”±sflagsè®¡ç®—                       |
| get_keys_proc   | ä¸€ä¸ªå¯é€‰å‡½æ•°ï¼Œç”¨äºè·å–å‘½ä»¤å‚æ•°ï¼Œåªæœ‰åœ¨first_key_indexï¼Œlast_key_indexï¼Œkey_stepæ— æ³•æŒ‡å®šå“ªäº›æ˜¯å‚æ•°æ—¶æ‰ä½¿ç”¨æ­¤é€‰é¡¹ |
| first_key_index | ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯key                                              |
| last_key_index  | æœ€åä¸€ä¸ªå‚æ•°æ˜¯key                                            |
| key_step        | keyä¹‹é—´çš„æ­¥é•¿ï¼Œå¦‚MSETæ­¥é•¿ä¸º2ï¼Œ MSET key value key2 value2 ... |
| microseconds    | æœåŠ¡å™¨æ‰§è¡Œè¯¥å‘½ä»¤è€—è´¹çš„æ—¶é—´                                   |
| calls           | æœåŠ¡å™¨æ€»å…±æ‰§è¡Œäº†å¤šå°‘æ¬¡è¯¥å‘½ä»¤                                 |

- å‘½ä»¤çš„å±æ€§sflagæ ‡è¯†

| æ ‡è¯† | æ„ä¹‰                                                         |
| ---- | ------------------------------------------------------------ |
| w    | å†™å‘½ä»¤                                                       |
| r    | è¯»å‘½ä»¤                                                       |
| m    | è¯¥å‘½ä»¤ä¼šå ç”¨å¤§é‡å†…å­˜ï¼Œæ‰§è¡Œä¹‹å‰éœ€è¦æ£€æŸ¥å†…å­˜æƒ…å†µ               |
| a    | ç®¡ç†å‘½ä»¤ï¼Œå¦‚SAVEï¼ŒSHUTDOWNç­‰                                 |
| p    | å‘å¸ƒè®¢é˜…æ¨¡å¼çš„å‘½ä»¤                                           |
| f    | å¼ºåˆ¶å¤åˆ¶å‘½ä»¤ï¼Œæ— è§†æœåŠ¡å™¨è„è®¡æ•°                               |
| s    | Luaè„šæœ¬ä¸­ä¸å…è®¸çš„å‘½ä»¤                                        |
| R    | éšæœºå‘½ä»¤ï¼Œç›¸åŒæƒ…å†µä¸‹ï¼Œç»“æœå¯èƒ½ä¸åŒ                           |
| S    | Luaè„šæœ¬ä¸­ä½¿ç”¨æ ‡è¯†åˆ™éœ€è¦å¯¹ç»“æœè¿›è¡Œæ’åº                        |
| l    | æœåŠ¡å™¨è½½å…¥æƒ…å†µä¸‹å¯ä»¥ä½¿ç”¨çš„å‘½ä»¤                               |
| t    | ä»èŠ‚ç‚¹æœåŠ¡å™¨æ•°æ®è¿‡æœŸæ—¶å…è®¸æ‰§è¡Œçš„å‘½ä»¤                         |
| M    | åœ¨MONITORæ¨¡å¼ä¸‹ä¸ä¼šè‡ªåŠ¨ä¼ æ’­                                  |
| k    | æ‰§è¡Œä¸€ä¸ªæ˜¾ç¤ºçš„ASKINGï¼Œä½¿å¾—åœ¨é›†ç¾¤æ¨¡å¼ä¸‹ï¼Œè¢«æ ‡å¿—ä¸ºimporingçš„æ§½å¯ä»¥æ¥å—è¯¥å‘½ä»¤ |
| F    | å¿«é€Ÿæ¨¡å¼ï¼ŒO(1)æˆ–O(log(N))çš„å¤æ‚åº¦                            |

#### 2.2 å‘½ä»¤è¯·æ±‚æ‰§è¡Œè¿‡ç¨‹

å®¢æˆ·ç«¯å‘é€å‘½ä»¤åˆ°æœåŠ¡ç«¯æ‰§è¡Œè¿”å›æœ‰ä¸€ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š

1. å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯å»ºç«‹è¿æ¥ï¼ŒæŒ‰ç…§ä¸€å®šæ ¼å¼å°è£…å‘½ä»¤

   ```bash
   # SET msg hello å‘½ä»¤è½¬æ¢åå¦‚ä¸‹
   *3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n
   ```

2. æœåŠ¡å™¨æ¥æ”¶åˆ°æ¥è‡ªç½‘ç»œå®¢æˆ·ç«¯çš„è¯·æ±‚æ•°æ®ï¼ŒæŒ‰ç…§åè®®æ ¼å¼è§£æå‘½ä»¤

   1. è¯»å–å¥—æ¥å­—ä¸­çš„å‘½ä»¤è¯·æ±‚ï¼Œå­˜å‚¨åˆ°å¯¹åº”çš„å®¢æˆ·ç«¯è¾“å…¥ç¼“å†²åŒºä¸­
   2. è¯»å–ç¼“å†²åŒºä¸­æ•°æ®ï¼Œè§£æå‘½ä»¤ï¼Œæå–å‘½ä»¤è¯·æ±‚å’Œå‚æ•°

3. è·å¾—è§£æå‘½ä»¤åæŸ¥æ‰¾æœåŠ¡å™¨çš„å‘½ä»¤è¡¨ï¼Œæ‰¾åˆ°å¯¹åº”çš„å‘½ä»¤åŠå…¶æ‰§è¡Œæ–¹æ³•

   1. æŸ¥æ‰¾æœåŠ¡å™¨å‘½ä»¤è¡¨åŒ¹é…redisCommandç»“æ„ä¸­çš„nameå­—æ®µ
   2. æŸ¥è¯¢åˆ°å‘½ä»¤åè·å–å…¶æ‰§è¡Œæ–¹æ³•ï¼Œå±æ€§ç­‰ï¼Œå°†å‘½ä»¤æ‰§è¡Œæ–¹æ³•ä¿å­˜åœ¨å®¢æˆ·ç«¯cmdå­—æ®µä¸­

4. æœåŠ¡å™¨æ ¹æ®æ‰§è¡Œå‘½ä»¤ï¼Œå¹¶è¿”å›å¤„ç†åæ•°æ®

5. å®¢æˆ·ç«¯æ¥æ”¶åˆ°æœåŠ¡å™¨å¤„ç†å›å¤

> å‘½ä»¤æ‰§è¡Œæ—¶ä¼šæ ¹æ®å…¶sflagæ ‡å¿—å’ŒæœåŠ¡å™¨è®¾ç½®æœ‰ä¸åŒçš„å¤„ç†æ“ä½œï¼Œå…·ä½“æƒ…å†µå¯çœ‹æºç 

### 3. Rediså‘¨æœŸæ€§ä»»åŠ¡

æœåŠ¡å™¨ä¸ºäº†ç»´æŠ¤è‡ªèº«èµ„æºï¼Œé»˜è®¤æ¯100æ¯«ç§’æ‰§è¡Œä¸€æ¬¡å‘¨æœŸæ€§ä»»åŠ¡serverCron()ï¼Œä¸»è¦è´Ÿè´£åˆ é™¤è¿‡æœŸé”®ã€æœåŠ¡å™¨çŠ¶æ€ç›‘æ§ã€æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ã€æ¸è¿›å¼rehashã€è§¦å‘BGSAVE/AOFé‡å†™å¹¶å¤„ç†å­è¿›ç¨‹ä¸­æ–­ã€ä»èŠ‚ç‚¹å¤åˆ¶é‡è¿ç­‰ç­‰ã€‚

#### 3.1 æ›´æ–°æœåŠ¡å™¨æ—¶é—´ç¼“å­˜

RedisæœåŠ¡å™¨å¾ˆå¤šåŠŸèƒ½éœ€è¦è·å–ç³»ç»Ÿå½“å‰æ—¶é—´ï¼Œè¯¥ç³»ç»Ÿè°ƒç”¨éœ€è¦æ¶ˆè€—ä¸€å®šçš„CPUæ—¶é—´ï¼Œå¯¹æŸäº›æ—¶é—´ç²¾åº¦è¦æ±‚ä¸é«˜çš„åŠŸèƒ½æˆ‘ä»¬å¯ä»¥åœ¨serverCron()ä¸­è·å–ç³»ç»Ÿæ—¶é—´åç¼“å­˜ä¸‹æ¥ï¼Œå¯ä»¥æœ‰æ•ˆçš„å‡å°‘ç³»ç»Ÿè°ƒç”¨æ¬¡æ•°ï¼ŒæœåŠ¡å™¨çŠ¶æ€ä¸­unixtimeå’Œmstimeå±æ€§ç”¨äºå­˜å‚¨æ—¶é—´ç¼“å­˜ã€‚

å¯¹äºæ—¥å¿—æ‰“å°ã€æ›´æ–°æœåŠ¡å™¨LRUæ—¶é’Ÿç­‰ä»»åŠ¡å¯ä»¥ä½¿ç”¨æœåŠ¡å™¨ç¼“å†²æ—¶é—´ï¼›å¯¹äºè¿‡æœŸé”®çš„æ£€æµ‹ã€æ…¢æŸ¥è¯¢æ—¥å¿—ç­‰éœ€è¦é«˜ç²¾åº¦æ—¶é—´ä»»åŠ¡æ¥è¯´ï¼Œéœ€è¦é‡æ–°ç³»ç»Ÿè°ƒç”¨è·å–æ—¶é—´æ¥è®¡ç®—ã€‚

#### 3.2 å¤„ç†SIGTERMä¿¡å·

å¯åŠ¨æœåŠ¡å™¨æ—¶ï¼ŒRedisä¼šè®¾ç½®SIGTERMä¿¡å·å¤„ç†å‡½æ•°ï¼Œå½“æœåŠ¡å™¨æ¥æ”¶åˆ°SIGTERMä¿¡å·æ—¶ï¼Œä¼šå¼€å¯shutdown_asapæ ‡è¯†ã€‚serverCron()å‡½æ•°ä¸­ï¼Œæ¯æ¬¡éƒ½ä¼šæ£€æµ‹è¯¥æ ‡è¯†ï¼Œå¦‚æœè®¾ç½®è¯¥æ ‡è¯†ï¼ŒæœåŠ¡å™¨ä¼šå®‰å…¨å…³é—­ï¼Œå¹¶è®°å½•æ—¥å¿—ã€‚

#### 3.3 å®¢æˆ·ç«¯èµ„æºç®¡ç†clientsCron()

serverCron()å‡½æ•°æ¯æ¬¡æ‰§è¡Œéƒ½ä¼šè°ƒç”¨clientsCronå‡½æ•°ï¼Œå› ä¸ºå‡½æ•°æ¯ç§’è°ƒç”¨server.hz(é»˜è®¤10)ï¼Œä¸ºäº†ç¡®ä¿æ¯ä¸ªå®¢æˆ·ç«¯è‡³å°‘æ‰§è¡Œä¸€ç§’ï¼Œæ‰€ä»¥è¿­ä»£æ¬¡æ•°è‡³å°‘ä¸ºnumclients/server.hzï¼Œè¯¥å‡½æ•°æ‰§è¡Œä»¥ä¸‹æ£€æŸ¥ï¼š

- å¦‚æœå®¢æˆ·ç«¯ä¸æœåŠ¡å™¨è¿æ¥è¶…æ—¶ï¼Œé‚£ä¹ˆé‡Šæ”¾è¯¥å®¢æˆ·ç«¯
- å¦‚æœå®¢æˆ·ç«¯è¾“å…¥ç¼“å†²åŒºè¶…è¿‡ä¸€å®šé™åˆ¶ï¼Œåˆ™é‡æ–°åˆ†é…ç¼“å­˜åŒºçš„å†…å­˜ç©ºé—´ï¼Œç¡®ä¿æ²¡æœ‰æµªè´¹

#### 3.4 ç®¡ç†æ•°æ®åº“èµ„æºdatabaseCron()

serverCron()å‡½æ•°æ¯æ¬¡æ‰§è¡Œä¼šè°ƒç”¨databaseCron()å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šå¯¹æ•°æ®åº“è¿›è¡Œæ£€æŸ¥ï¼Œåˆ é™¤è¿‡æœŸé”®ï¼Œresizeï¼Œrehashç­‰æ“ä½œã€‚

- ä¸»èŠ‚ç‚¹åˆ™å¼€å¯è¿‡æœŸé”®è‡ªåŠ¨åˆ é™¤åŠŸèƒ½ï¼Œä»èŠ‚ç‚¹ç›´æ¥åˆ é™¤è¿‡æœŸé”®
- å†…å­˜ç¢ç‰‡æ•´ç†
- å¦‚æœæœåŠ¡å™¨ä¸ºè¿›è¡ŒAOFæˆ–RDBï¼Œåˆ™è¿›è¡ŒRehashå’ŒResize

#### 3.5 æŒä¹…åŒ–è®°å½•

å¦‚æœæœåŠ¡å™¨æ²¡æœ‰RDBæˆ–AOFæŒä¹…æ­£åœ¨è¿›è¡Œï¼Œé‚£ä¹ˆå¼€å¯åå°çš„AOFé‡å†™ä»»åŠ¡ï¼›å¦‚æœæœ‰RDBæˆ–AOFï¼Œåˆ™ç­‰å¾…å­è¿›ç¨‹ä¿¡å·ï¼Œå¦‚æœæ¥æ”¶åˆ°ä¿¡å·è¯´æ˜æŒä¹…åŒ–å·²å®Œæˆï¼Œå¦åˆ™è¡¨ç¤ºæœªå®Œæˆã€‚

> å³ä½¿AOFé‡å†™é”™è¯¯ï¼Œä¹Ÿéœ€è¦åˆ·æ–°AOFç¼“å†²åŒº

#### 3.6 æ›´æ–°ä¿¡æ¯å¹¶è®°å½•æ—¥å¿—

- æ›´æ–°æœåŠ¡å™¨æ¯ç§’æ‰§è¡Œå‘½ä»¤æ¬¡æ•°
- æ›´æ–°LRUæ—¶é’Ÿ
- æ›´æ–°å†…å­˜ä½¿ç”¨å³°å€¼
- è®°å½•éç©ºæ•°æ®åº“æ—¥å¿—
- éå“¨å…µæ¨¡å¼æœåŠ¡å™¨ï¼Œè®°å½•å®¢æˆ·ç«¯è¿æ¥æ—¥å¿—

#### 3.7 å…¶ä»–ä¸€äº›ä»»åŠ¡

- å¼‚æ­¥å…³é—­éœ€è¦å…³é—­çš„å®¢æˆ·ç«¯

- å¦‚æœéœ€è¦è§£é™¤å®¢æˆ·ç«¯æš‚åœçŠ¶æ€

- å‘¨æœŸæ€§å¤åˆ¶ä»»åŠ¡

- é›†ç¾¤æ¨¡å¼ä¸‹ï¼Œé›†ç¾¤å‘¨æœŸæ€§ä»»åŠ¡

- å“¨å…µæ¨¡å¼ä¸‹ä»»åŠ¡

- æ¸…ç†socketsè¿æ¥


### 4. æºç å‰–æ

- å‘¨æœŸæ€§ä»»åŠ¡

```c
/**
 * æœåŠ¡å™¨å‘¨æœŸä»»åŠ¡, æ¯ç§’è°ƒç”¨server.hzæ¬¡
 * éœ€è¦æ‰§è¡Œä¸€äº›å¼‚æ­¥ä»»åŠ¡ï¼š
 *   - ä¸»åŠ¨åˆ é™¤è¿‡æœŸé”®é›†åˆ(ä¹Ÿå¯ä»¥åœ¨è¯»æ“ä½œæ—¶æ‡’åˆ é™¤)
 *   - è½¯ä»¶ç›‘æ§ï¼ŒğŸ¶çœ‹é—¨ç‹—ğŸ¶
 *   - æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
 *   - æ¸è¿›å¼rehash
 *   - è§¦å‘BGSAVE/AOFé‡å†™, å¤„ç†å­è¿›ç¨‹ä¸­æ–­
 *   - ä¸åŒç±»å‹å®¢æˆ·ç«¯çš„è¶…æ—¶æ—¶é—´
 *   - å¤åˆ¶é‡è¿
 *
 * è¿™é‡Œè°ƒç”¨ä¼šæ¯ç§’æ‰§è¡Œserver.hzæ¬¡ï¼Œæ‰€ä»¥ä¸ºäº†ç®€ä¾¿ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå®run_with_period 
 */
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    int j;
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    /* Software watchdog: deliver the SIGALRM that will reach the signal
     * handler if we don't return here fast enough. */
    // å®šæœŸå‘é€ä¸€ä¸ª SIGALRM ä¿¡å·
    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);

    /* Update the time cache. */
    // æ›´æ–°æœåŠ¡å™¨æ—¶é—´ç¼“å­˜
    updateCachedTime();

    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    run_with_period(100) {
        // å‘½ä»¤æ‰§è¡Œæ¬¡æ•°
        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);
        // ç½‘ç»œè¯»å–å­—èŠ‚æ•°
        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,
                server.stat_net_input_bytes);
        // ç½‘ç»œè¾“å‡ºå­—èŠ‚æ•°
        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,
                server.stat_net_output_bytes);
    }

    /* We have just LRU_BITS bits per object for LRU information.
     * So we use an (eventually wrapping) LRU clock.
     *
     * Note that even if the counter wraps it's not a big problem,
     * everything will still work but some object will appear younger
     * to Redis. However for this to happen a given object should never be
     * touched for all the time needed to the counter to wrap, which is
     * not likely.
     *
     * Note that you can change the resolution altering the
     * LRU_CLOCK_RESOLUTION define. */
    // æœåŠ¡å™¨LRUæ—¶é’Ÿ
    unsigned long lruclock = getLRUClock();
    atomicSet(server.lruclock,lruclock);

    /* Record the max memory used since the server was started. */
    // è®°å½•ä½¿ç”¨å†…å­˜å³°å€¼
    if (zmalloc_used_memory() > server.stat_peak_memory)
        server.stat_peak_memory = zmalloc_used_memory();

    /* Sample the RSS here since this is a relatively slow call. */
    // è®°å½•å¸¸é©»å†…å­˜å¤§å°
    server.resident_set_size = zmalloc_get_rss();

    /* We received a SIGTERM, shutting down here in a safe way, as it is
     * not ok doing so inside the signal handler. */
    // æ¥æ”¶åˆ°SIGTERMä¿¡å·ï¼Œå®‰å…¨å…³é—­æœåŠ¡å™¨
    if (server.shutdown_asap) {
        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);
        serverLog(LL_WARNING,"SIGTERM received but errors trying to shut down the server, check the logs for more information");
        server.shutdown_asap = 0;
    }

    /* Show some info about non-empty databases */
    // è®°å½•éç©ºæ•°æ®åº“æ—¥å¿—
    run_with_period(5000) {
        for (j = 0; j < server.dbnum; j++) {
            long long size, used, vkeys;

            size = dictSlots(server.db[j].dict);
            used = dictSize(server.db[j].dict);
            vkeys = dictSize(server.db[j].expires);
            if (used || vkeys) {
                serverLog(LL_VERBOSE,"DB %d: %lld keys (%lld volatile) in %lld slots HT.",j,used,vkeys,size);
                /* dictPrintStats(server.dict); */
            }
        }
    }

    /* Show information about connected clients */
    // éå“¨å…µæ¨¡å¼æœåŠ¡å™¨ï¼Œè®°å½•å®¢æˆ·ç«¯è¿æ¥ä¿¡æ¯åˆ°æ—¥å¿—ä¸­
    if (!server.sentinel_mode) {
        run_with_period(5000) {
            serverLog(LL_VERBOSE,
                "%lu clients connected (%lu slaves), %zu bytes in use",
                listLength(server.clients)-listLength(server.slaves),
                listLength(server.slaves),
                zmalloc_used_memory());
        }
    }

    /* We need to do a few operations on clients asynchronously. */
    // å®¢æˆ·ç«¯å‘¨æœŸæ€§ä»»åŠ¡
    clientsCron();

    /* Handle background operations on Redis databases. */
    // æ•°æ®åº“å‘¨æœŸæ€§ä»»åŠ¡
    databasesCron();

    /* Start a scheduled AOF rewrite if this was requested by the user while
     * a BGSAVE was in progress. */
    // å¦‚æœæ²¡æœ‰RDBæˆ–AOFæ‰§è¡Œï¼Œé‚£ä¹ˆå¼€å¯åå°AOFé‡å†™æ“ä½œ
    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
        server.aof_rewrite_scheduled)
    {
        rewriteAppendOnlyFileBackground();
    }

    /* Check if a background saving or AOF rewrite in progress terminated. */
    // å¦‚æœæ­£åœ¨è¿›è¡ŒRDBæˆ–AOFé‡å†™æ“ä½œï¼Œé‚£ä¹ˆç­‰å¾…å­è¿›ç¨‹ä¿¡å·
    if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||
        ldbPendingChildren())
    {
        int statloc;
        pid_t pid;

        if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {
            int exitcode = WEXITSTATUS(statloc);
            int bysignal = 0;

            if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);

            if (pid == -1) {
                serverLog(LL_WARNING,"wait3() returned an error: %s. "
                    "rdb_child_pid = %d, aof_child_pid = %d",
                    strerror(errno),
                    (int) server.rdb_child_pid,
                    (int) server.aof_child_pid);
            } else if (pid == server.rdb_child_pid) {
                backgroundSaveDoneHandler(exitcode,bysignal);
                if (!bysignal && exitcode == 0) receiveChildInfo();
            } else if (pid == server.aof_child_pid) {
                backgroundRewriteDoneHandler(exitcode,bysignal);
                if (!bysignal && exitcode == 0) receiveChildInfo();
            } else {
                if (!ldbRemoveChild(pid)) {
                    serverLog(LL_WARNING,
                        "Warning, detected child with unmatched pid: %ld",
                        (long)pid);
                }
            }
            updateDictResizePolicy();
            closeChildInfoPipe();
        }

        // æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„RDBæˆ–AOFï¼Œé‚£ä¹ˆæ£€æŸ¥æ˜¯å¦éœ€è¦æ‰§è¡Œ
    } else {
        /* If there is not a background saving/rewrite in progress check if
         * we have to save/rewrite now. */
         for (j = 0; j < server.saveparamslen; j++) {
            struct saveparam *sp = server.saveparams+j;

            /* Save if we reached the given amount of changes,
             * the given amount of seconds, and if the latest bgsave was
             * successful or if, in case of an error, at least
             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */
            if (server.dirty >= sp->changes &&
                server.unixtime-server.lastsave > sp->seconds &&
                (server.unixtime-server.lastbgsave_try >
                 CONFIG_BGSAVE_RETRY_DELAY ||
                 server.lastbgsave_status == C_OK))
            {
                serverLog(LL_NOTICE,"%d changes in %d seconds. Saving...",
                    sp->changes, (int)sp->seconds);
                rdbSaveInfo rsi, *rsiptr;
                rsiptr = rdbPopulateSaveInfo(&rsi);
                rdbSaveBackground(server.rdb_filename,rsiptr);
                break;
            }
         }

         /* Trigger an AOF rewrite if needed. */
         // æ ¹æ®éœ€è¦è§¦å‘AOF
         if (server.aof_state == AOF_ON &&
             server.rdb_child_pid == -1 &&
             server.aof_child_pid == -1 &&
             server.aof_rewrite_perc &&
             server.aof_current_size > server.aof_rewrite_min_size)
         {
            long long base = server.aof_rewrite_base_size ?
                            server.aof_rewrite_base_size : 1;
            long long growth = (server.aof_current_size*100/base) - 100;
            if (growth >= server.aof_rewrite_perc) {
                serverLog(LL_NOTICE,"Starting automatic rewriting of AOF on %lld%% growth",growth);
                rewriteAppendOnlyFileBackground();
            }
         }
    }


    /* AOF postponed flush: Try at every cron cycle if the slow fsync
     * completed. */
    // AOFç¼“å†²åŒºå†²æ´—åˆ°ç£ç›˜ä¸­
    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);

    /* AOF write errors: in this case we have a buffer to flush as well and
     * clear the AOF error in case of success to make the DB writable again,
     * however to try every second is enough in case of 'hz' is set to
     * an higher frequency. */
    // å³ä½¿AOFé‡å†™é”™è¯¯ï¼Œä¹Ÿåˆ·æ–°AOFç¼“å†²åŒº
    run_with_period(1000) {
        if (server.aof_last_write_status == C_ERR)
            flushAppendOnlyFile(0);
    }

    /* Close clients that need to be closed asynchronous */
    // å¼‚æ­¥å…³é—­å®¢æˆ·ç«¯
    freeClientsInAsyncFreeQueue();

    /* Clear the paused clients flag if needed. */
    // å¦‚æœéœ€è¦è§£é™¤å®¢æˆ·ç«¯æš‚åœçŠ¶æ€
    clientsArePaused(); /* Don't check return value, just use the side effect.*/

    /* Replication cron function -- used to reconnect to master,
     * detect transfer failures, start background RDB transfers and so forth. */
    // å‘¨æœŸæ€§å¤åˆ¶ä»»åŠ¡
    run_with_period(1000) replicationCron();

    /* Run the Redis Cluster cron. */
    // é›†ç¾¤å‘¨æœŸæ€§ä»»åŠ¡
    run_with_period(100) {
        if (server.cluster_enabled) clusterCron();
    }

    /* Run the Sentinel timer if we are in sentinel mode. */
    // å“¨å…µtimer
    run_with_period(100) {
        if (server.sentinel_mode) sentinelTimer();
    }

    /* Cleanup expired MIGRATE cached sockets. */
    // æ¸…ç†socketé“¾æ¥
    run_with_period(1000) {
        migrateCloseTimedoutSockets();
    }

    /* Start a scheduled BGSAVE if the corresponding flag is set. This is
     * useful when we are forced to postpone a BGSAVE because an AOF
     * rewrite is in progress.
     *
     * Note: this code must be after the replicationCron() call above so
     * make sure when refactoring this file to keep this order. This is useful
     * because we want to give priority to RDB savings for replication. */
    // å¦‚æœè®¾ç½®äº†ç›¸åº”æ ‡å¿—ï¼Œåˆ™å¯åŠ¨é¢„å®šçš„BGSAVEã€‚
    // è¿™æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œå½“æˆ‘ä»¬å¼ºåˆ¶å»¶è¿ŸBGSAVEï¼Œå› ä¸ºAOFé‡å†™æ­£åœ¨æ‰§è¡Œ
    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
        server.rdb_bgsave_scheduled &&
        (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||
         server.lastbgsave_status == C_OK))
    {
        rdbSaveInfo rsi, *rsiptr;
        rsiptr = rdbPopulateSaveInfo(&rsi);
        if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)
            server.rdb_bgsave_scheduled = 0;
    }

    // å‘¨æœŸå¾ªç¯+1
    server.cronloops++;
    // é»˜è®¤100ms
    return 1000/server.hz;
}
```

- è¿›å…¥äº‹ä»¶å¾ªç¯å‰è°ƒç”¨

```c
/**
 * Redisè¿›å…¥äº‹ä»¶å¾ªç¯å‰è¢«è°ƒç”¨ï¼Œå‡†å¤‡æ–‡ä»¶æè¿°ç¬¦
 */
void beforeSleep(struct aeEventLoop *eventLoop) {
    UNUSED(eventLoop);

    /* Call the Redis Cluster before sleep function. Note that this function
     * may change the state of Redis Cluster (from ok to fail or vice versa),
     * so it's a good idea to call it before serving the unblocked clients
     * later in this function. */
    // é›†ç¾¤æ¨¡å¼å¼€å¯beforeSleep, å¯èƒ½ä¼šæ”¹å˜redisé›†ç¾¤çš„çŠ¶æ€ï¼Œ
    if (server.cluster_enabled) clusterBeforeSleep();

    /* Run a fast expire cycle (the called function will return
     * ASAP if a fast cycle is not needed). */
    // ä¸»èŠ‚ç‚¹å¼€å¯è¿‡æœŸé”®åˆ é™¤ï¼Œåˆ™ä»¥å¿«é€Ÿæ¨¡å¼è¿è¡Œ
    if (server.active_expire_enabled && server.masterhost == NULL)
        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);

    /* Send all the slaves an ACK request if at least one client blocked
     * during the previous event loop iteration. */
    // å¦‚æœåœ¨å‰ä¸€ä¸ªäº‹ä»¶å¾ªç¯è¿­ä»£æœŸé—´æœ‰å®¢æˆ·ç«¯è¢«é˜»å¡ï¼Œåˆ™å‘æ‰€æœ‰ä»èŠ‚ç‚¹å‘é€ACKè¯·æ±‚
    if (server.get_ack_from_slaves) {
        robj *argv[3];

        // æ„å»ºå‚æ•°
        argv[0] = createStringObject("REPLCONF",8);
        argv[1] = createStringObject("GETACK",6);
        argv[2] = createStringObject("*",1); /* Not used argument. */

        // ç»™ä»èŠ‚ç‚¹æœåŠ¡å™¨å‘é€è¯·æ±‚
        replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);

        // é‡Šæ”¾æ„å»ºçš„å‚æ•°
        decrRefCount(argv[0]);
        decrRefCount(argv[1]);
        decrRefCount(argv[2]);

        // æ¸…ç©ºæ ‡å¿—
        server.get_ack_from_slaves = 0;
    }

    /* Unblock all the clients blocked for synchronous replication
     * in WAIT. */
    // è§£é™¤æ‰€æœ‰ç­‰å¾…WAITå‘½ä»¤è€Œè¢«é˜»å¡çš„å®¢æˆ·ç«¯
    if (listLength(server.clients_waiting_acks))
        processClientsWaitingReplicas();

    /* Check if there are clients unblocked by modules that implement
     * blocking commands. */
    // æ£€æŸ¥æ˜¯å¦æœ‰æ¨¡å—é˜»å¡å‘½ä»¤è§£é™¤é˜»å¡å®¢æˆ·ç«¯
    moduleHandleBlockedClients();

    /* Try to process pending commands for clients that were just unblocked. */
    // å¤„ç†éé˜»å¡å®¢æˆ·ç«¯çš„è¾“å…¥ç¼“å†²åŒº
    if (listLength(server.unblocked_clients))
        processUnblockedClients();

    /* Write the AOF buffer on disk */
    // å°†AOFç¼“å†²åŒºå†²æ´—åˆ°ç£ç›˜ä¸­
    flushAppendOnlyFile(0);

    /* Handle writes with pending output buffers. */
    // å¤„ç†å¾…å†™çš„è¾“å‡ºç¼“å†²åŒº
    handleClientsWithPendingWrites();

    /* Before we are going to sleep, let the threads access the dataset by
     * releasing the GIL. Redis main thread will not touch anything at this
     * time. */
    // åœ¨è¿›å…¥sleepä¹‹å‰ï¼Œè®©çº¿ç¨‹é‡Šæ”¾GILæ¥è®¿é—®æ•°æ®é›†ã€‚
    // Redisä¸»çº¿ç¨‹æ­¤æ—¶ä¸ä¼šè§¦åŠä»»ä½•å†…å®¹
    if (moduleCount()) moduleReleaseGIL();
}
```

